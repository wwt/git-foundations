{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Git Foundations Hands-On Walkthrough Overview Git is a distributed source control management (SCM) tool. This walkthrough is a series of practical, hands-on exercises to familiarize you with the use of Git and assumes you understand some Git use cases, terminology, and file areas (working, staging, & HEAD). If you need some quick and dirty Git background information, check out these resources: Version Control 101 \u2014 WWT Video (16 minutes) WWT Programmability Foundations Lab \u2014 Version Control Section What You Need A Windows or macOS computer with Docker Desktop . If you are new to Docker, here are the Docker Desktop Installation Documentation . Alternatively, you can install Docker in a Linux Environment and complete the walkthrough. An account on github.com . Your favorite terminal/shell program (iTerm, PowerShell, Bash, etc.). Contents Hands-On Environment Setup Setup GitHub Authentication Create a GitHub Repository Create a New Branch in a GitHub Repository Clone a GitHub Repository to Your Computer View & Configure Local Git Settings on Your Computer Manage Local Git Branches Make Local Git Repository Changes Make Local Git Repository Changes With Atomic Commits Review Changes in the GitHub Repository Pull/Merge Changes in GitHub Review The Pull Request Impact to Your Local Git Repository Clone Another Repository, Make Changes, and Create a New Pull Request Get Started That's all there is to it! Click this link to get started: Next Section > Hands-On Environment Setup","title":"Home"},{"location":"#git-foundations-hands-on-walkthrough","text":"","title":"Git Foundations Hands-On Walkthrough"},{"location":"#overview","text":"Git is a distributed source control management (SCM) tool. This walkthrough is a series of practical, hands-on exercises to familiarize you with the use of Git and assumes you understand some Git use cases, terminology, and file areas (working, staging, & HEAD). If you need some quick and dirty Git background information, check out these resources: Version Control 101 \u2014 WWT Video (16 minutes) WWT Programmability Foundations Lab \u2014 Version Control Section","title":"Overview"},{"location":"#what-you-need","text":"A Windows or macOS computer with Docker Desktop . If you are new to Docker, here are the Docker Desktop Installation Documentation . Alternatively, you can install Docker in a Linux Environment and complete the walkthrough. An account on github.com . Your favorite terminal/shell program (iTerm, PowerShell, Bash, etc.).","title":"What You Need"},{"location":"#contents","text":"Hands-On Environment Setup Setup GitHub Authentication Create a GitHub Repository Create a New Branch in a GitHub Repository Clone a GitHub Repository to Your Computer View & Configure Local Git Settings on Your Computer Manage Local Git Branches Make Local Git Repository Changes Make Local Git Repository Changes With Atomic Commits Review Changes in the GitHub Repository Pull/Merge Changes in GitHub Review The Pull Request Impact to Your Local Git Repository Clone Another Repository, Make Changes, and Create a New Pull Request","title":"Contents"},{"location":"#get-started","text":"That's all there is to it! Click this link to get started: Next Section > Hands-On Environment Setup","title":"Get Started"},{"location":"sections/section_1/","text":"Hands-On Environment Setup A WWT-built Docker Image provides a ready-to-use environment for the Git hands-on exercises. The Docker Container already has Git software installed and you don't need any Docker experience for these exercises. Just make sure you have Docker Desktop installed and running on your Windows or macOS computer and we will walk you through the development environment setup. Tip You can use your terminal/shell program to confirm your Docker environment is ready for use with the following command: docker info Success If your output looks something like this image, you are all set: Failure If you see an error message similiar to the example below, make sure you installed Docker Desktop and that Docker Desktop is running. You may also review the Docker Desktop Installation Documentation . There are two-steps in the process (download and then run) to create the Docker Container we need from the WWT-built Docker Image, but we will accomplish both steps with a single command. Open your terminal/shell program (iTerm, PowerShell, Bash, etc.) and enter the following command: docker container run -it --name git-foundations wwt01/alpine-network-dev This command performs the following actions: Downloads the 'wwt01/alpine-network-dev' Image from Docker Hub . Creates a Docker Container with the name 'git-foundations'. Attaches to the terminal of the 'git-foundations' Container. Expect the first run of this command to take a few minutes, while Docker Desktop downloads the Image from Docker Hub. Docker Desktop stores the Image on your computer, so subsequent runs of this command will only take a split second. You will know your Docker Container environment is ready for the Git hands-on exercises when your terminal prompt changes to /development# : If you aren't sure whether you are at your computer's terminal prompt or the prompt within the Docker Container, you can use this command to check: # Display the contents of the Container operating system release file cat /etc/*-release Tip The Container will ignore any commands/lines that begin with the # character, treating those lines as inline comments. Throughout the walkthrough documentation, you may copy entire blocks of commands and paste them in the Container terminal. These purpose of these comment lines is to explain specifically what the subsequent commands do. You are in the Docker Container environment if your output looks like this: Check the version of Git in the environment with the following command: git --version The result of that command should look something like this: Here is a quick reference for some other Docker commands which will help you manage your Git hands-on environment: Attention Run these commands from your local terminal shell (Windows PowerShell, macOS Terminal, etc.) and not from within the Docker container shell: control + d ( key sequence ) # Stops your Container and returns you to your terminal prompt docker container start git-foundations # Restarts your Container in the background docker container attach git-foundations # Returns you to the Container prompt docker container rm git-foundations # Destroys your container so you can start over Your environment is set up and ready to use! Not too painful so far, right? Click the link below to get started with Git: Next Section > Setup GitHub Authentication","title":"Hands-On Environment Setup"},{"location":"sections/section_1/#hands-on-environment-setup","text":"A WWT-built Docker Image provides a ready-to-use environment for the Git hands-on exercises. The Docker Container already has Git software installed and you don't need any Docker experience for these exercises. Just make sure you have Docker Desktop installed and running on your Windows or macOS computer and we will walk you through the development environment setup. Tip You can use your terminal/shell program to confirm your Docker environment is ready for use with the following command: docker info Success If your output looks something like this image, you are all set: Failure If you see an error message similiar to the example below, make sure you installed Docker Desktop and that Docker Desktop is running. You may also review the Docker Desktop Installation Documentation . There are two-steps in the process (download and then run) to create the Docker Container we need from the WWT-built Docker Image, but we will accomplish both steps with a single command. Open your terminal/shell program (iTerm, PowerShell, Bash, etc.) and enter the following command: docker container run -it --name git-foundations wwt01/alpine-network-dev This command performs the following actions: Downloads the 'wwt01/alpine-network-dev' Image from Docker Hub . Creates a Docker Container with the name 'git-foundations'. Attaches to the terminal of the 'git-foundations' Container. Expect the first run of this command to take a few minutes, while Docker Desktop downloads the Image from Docker Hub. Docker Desktop stores the Image on your computer, so subsequent runs of this command will only take a split second. You will know your Docker Container environment is ready for the Git hands-on exercises when your terminal prompt changes to /development# : If you aren't sure whether you are at your computer's terminal prompt or the prompt within the Docker Container, you can use this command to check: # Display the contents of the Container operating system release file cat /etc/*-release Tip The Container will ignore any commands/lines that begin with the # character, treating those lines as inline comments. Throughout the walkthrough documentation, you may copy entire blocks of commands and paste them in the Container terminal. These purpose of these comment lines is to explain specifically what the subsequent commands do. You are in the Docker Container environment if your output looks like this: Check the version of Git in the environment with the following command: git --version The result of that command should look something like this: Here is a quick reference for some other Docker commands which will help you manage your Git hands-on environment: Attention Run these commands from your local terminal shell (Windows PowerShell, macOS Terminal, etc.) and not from within the Docker container shell: control + d ( key sequence ) # Stops your Container and returns you to your terminal prompt docker container start git-foundations # Restarts your Container in the background docker container attach git-foundations # Returns you to the Container prompt docker container rm git-foundations # Destroys your container so you can start over Your environment is set up and ready to use! Not too painful so far, right? Click the link below to get started with Git: Next Section > Setup GitHub Authentication","title":"Hands-On Environment Setup"},{"location":"sections/section_10/","text":"Review Changes in the GitHub Repository Let's take a look at how the changes we pushed from our local Git repository impact the GitHub repository. Local Repository Push Review Return to GitHub and notice a few things about the repository: There is still just one commit on the main branch; we haven't yet merged the changes in branch3 to the main branch. The GitHub repository now has three branches, up from two before we pushed branch3 from our local Git repository to GitHub. There is a highlighted message indicating a recently pushed branch ( branch3 ). Expand the Branch: main drop menu and notice there three branches, main , branch1 , and branch3 . Click on branch3 : From the branch3 view, notice GitHub shows us that branch3 is two commits ahead of the main branch. These two commits represent the two commits we made to our local repository and then pushed to GitHub. Click on the 3 commits link to review the individual commits. The branch3 commits view shows three total commits. One of the commits is the initial commit that occurred when we created the repository. We can also see the two atomic commits from our local Git repository along with the messages we added with the git commit -m commands. Even though the git push command sent all of our local repository to GitHub at once, the individual atomic commits remain separate and reviewable. Click the git-repo-1 link at the top of the window to return to the repository home page. Now we can start the process to merge our local changes to the GitHub repository, from branch3 , into the main branch. Click the link below to continue: Next Section > Pull/Merge Changes in GitHub","title":"Review Changes in the GitHub Repository"},{"location":"sections/section_10/#review-changes-in-the-github-repository","text":"Let's take a look at how the changes we pushed from our local Git repository impact the GitHub repository.","title":"Review Changes in the GitHub Repository"},{"location":"sections/section_10/#local-repository-push-review","text":"Return to GitHub and notice a few things about the repository: There is still just one commit on the main branch; we haven't yet merged the changes in branch3 to the main branch. The GitHub repository now has three branches, up from two before we pushed branch3 from our local Git repository to GitHub. There is a highlighted message indicating a recently pushed branch ( branch3 ). Expand the Branch: main drop menu and notice there three branches, main , branch1 , and branch3 . Click on branch3 : From the branch3 view, notice GitHub shows us that branch3 is two commits ahead of the main branch. These two commits represent the two commits we made to our local repository and then pushed to GitHub. Click on the 3 commits link to review the individual commits. The branch3 commits view shows three total commits. One of the commits is the initial commit that occurred when we created the repository. We can also see the two atomic commits from our local Git repository along with the messages we added with the git commit -m commands. Even though the git push command sent all of our local repository to GitHub at once, the individual atomic commits remain separate and reviewable. Click the git-repo-1 link at the top of the window to return to the repository home page. Now we can start the process to merge our local changes to the GitHub repository, from branch3 , into the main branch. Click the link below to continue: Next Section > Pull/Merge Changes in GitHub","title":"Local Repository Push Review"},{"location":"sections/section_11/","text":"Pull/Merge Changes in GitHub A pull request is GitHub's terminology for starting the process to merge changes from one branch into another. In this example, we will merge changes from branch3 into main , effectively updating the mainline version of the files in the GitHub repository. Create a Pull Request Locate and click the green Compare & pull request button: Add the following details to the pull request : Title - Branch3 Comment - Merge of changes from ** branch3** to **main** Click on the the Reviewers list. Typically, you would assign at least one reviewer to a pull request . This allows yout to ask a peer to put a second set of eyes on your changes before a merge occurrs. GitHub does not allow you to assign your own GitHub account as a reviewer of a pull request that you create. For this exercise, you don't need to enter anything in the Reviewers list. Click the green Create pull request button: Merge the Pull Request Review the details of the pull request and then click the green Merge pull request button: GitHub gives you one more prompt to confirm the merge action. Click the green Confirm merge button to complete the pull request . Remove Branch3 from GitHub Just in case you didn't confirm the merge action enough already, GitHub gives you the option to revert the operation. For the purpose of this walkthrough, we can skip this step. In some cases, you may want to retain branches after you merge their changes into the main branch, or any other branch. In this case, we will remove branch3 to keep from cluttering the repository with a history of every branch. Click the Delete branch button to remove branch3 from GitHub. Click the git-repo-1 link at the top of the window to return to the repository home page. Notice the message which indicates the merge of the pull request . We are just about done. Next up, we will look at how the merge of the pull request in GitHub impacts our local Git repository. Click the link below to continue: Next Section > Review The Pull Request Impact to Your Local Git Repository","title":"Pull/Merge Changes in GitHub"},{"location":"sections/section_11/#pullmerge-changes-in-github","text":"A pull request is GitHub's terminology for starting the process to merge changes from one branch into another. In this example, we will merge changes from branch3 into main , effectively updating the mainline version of the files in the GitHub repository.","title":"Pull/Merge Changes in GitHub"},{"location":"sections/section_11/#create-a-pull-request","text":"Locate and click the green Compare & pull request button: Add the following details to the pull request : Title - Branch3 Comment - Merge of changes from ** branch3** to **main** Click on the the Reviewers list. Typically, you would assign at least one reviewer to a pull request . This allows yout to ask a peer to put a second set of eyes on your changes before a merge occurrs. GitHub does not allow you to assign your own GitHub account as a reviewer of a pull request that you create. For this exercise, you don't need to enter anything in the Reviewers list. Click the green Create pull request button:","title":"Create a Pull Request"},{"location":"sections/section_11/#merge-the-pull-request","text":"Review the details of the pull request and then click the green Merge pull request button: GitHub gives you one more prompt to confirm the merge action. Click the green Confirm merge button to complete the pull request .","title":"Merge the Pull Request"},{"location":"sections/section_11/#remove-branch3-from-github","text":"Just in case you didn't confirm the merge action enough already, GitHub gives you the option to revert the operation. For the purpose of this walkthrough, we can skip this step. In some cases, you may want to retain branches after you merge their changes into the main branch, or any other branch. In this case, we will remove branch3 to keep from cluttering the repository with a history of every branch. Click the Delete branch button to remove branch3 from GitHub. Click the git-repo-1 link at the top of the window to return to the repository home page. Notice the message which indicates the merge of the pull request . We are just about done. Next up, we will look at how the merge of the pull request in GitHub impacts our local Git repository. Click the link below to continue: Next Section > Review The Pull Request Impact to Your Local Git Repository","title":"Remove Branch3 from GitHub"},{"location":"sections/section_12/","text":"Review The Pull Request Impact to Your Local Git Repository The GitHub repository has a new version of the main branch but the main branch in our local repository isn't aware of the changes yet (only our local branch3 branch is aware of the changes). Before we make new changes to our local GIt repository, let's get it in sync with GitHub and clean up the branch ( branch3 ) which is no longer in GitHub. Pull Changes from GitHub From the Docker Container terminal, attempt to pull (download and merge) the latest changes from GitHub to your local repository with the following command: # Download and merge changes from the remote repository to the local repository git pull Notice the last two lines of the output which indicate Git attempted to pull changes from GitHub and merge those changes with branch3 in the local Git repository. However, the local Git repository was unable to locate branch3 in GitHub because, of course, we deleted branch3 in GitHub after merging our pull request . List your local branches with the following command: # Display all local git branches git branch Notice branch3 remains in your local repository and is the current, working branch. Change your working branch to main with the following command: # Switch the working branch from 'branch3' to 'main' git checkout main Notice the message which indicates the local Git repository branch main is behind the GitHub main branch ( origin/main ) by three commits and can be fast-forwarded (synchronized with the latest changes). Download and merge the GitHub main branch with your local Git repository main branch using the following command: # Download and merge changes from the remote repository to the local repository git pull Notice the output which indicates the file changes and insertions. Since our local Git repository main branch now in sync with the latest copy of the GitHub repository main branch, we no longer need our local copy of branch3 . Remove branch3 from the local repository with the following command: # Delete the local branch named 'branch3' git branch -d branch3 Confirm branch3 no longer exists in the local Git repository with the following command: # Display all local git branches git branch Notice that main is now the only branch in your local Git repository. You did it! You: Set up a new GitHub repository. Set up a local Git environment in a Docker Container. Managed local Git repository branches. Staged and committed local Git repository changes. Pushed branches and changes from your local Git environment to GitHub. Merged changes in GitHub with a pull request. Synchronized merged GitHub changes to your local Git environment. Click the link below to go to the last section and finish things up: Next Section > Clone Another Repository, Make Changes, and Create a New Pull Request","title":"Review The Pull Request Impact to Your Local Git Repository"},{"location":"sections/section_12/#review-the-pull-request-impact-to-your-local-git-repository","text":"The GitHub repository has a new version of the main branch but the main branch in our local repository isn't aware of the changes yet (only our local branch3 branch is aware of the changes). Before we make new changes to our local GIt repository, let's get it in sync with GitHub and clean up the branch ( branch3 ) which is no longer in GitHub.","title":"Review The Pull Request Impact to Your Local Git Repository"},{"location":"sections/section_12/#pull-changes-from-github","text":"From the Docker Container terminal, attempt to pull (download and merge) the latest changes from GitHub to your local repository with the following command: # Download and merge changes from the remote repository to the local repository git pull Notice the last two lines of the output which indicate Git attempted to pull changes from GitHub and merge those changes with branch3 in the local Git repository. However, the local Git repository was unable to locate branch3 in GitHub because, of course, we deleted branch3 in GitHub after merging our pull request . List your local branches with the following command: # Display all local git branches git branch Notice branch3 remains in your local repository and is the current, working branch. Change your working branch to main with the following command: # Switch the working branch from 'branch3' to 'main' git checkout main Notice the message which indicates the local Git repository branch main is behind the GitHub main branch ( origin/main ) by three commits and can be fast-forwarded (synchronized with the latest changes). Download and merge the GitHub main branch with your local Git repository main branch using the following command: # Download and merge changes from the remote repository to the local repository git pull Notice the output which indicates the file changes and insertions. Since our local Git repository main branch now in sync with the latest copy of the GitHub repository main branch, we no longer need our local copy of branch3 . Remove branch3 from the local repository with the following command: # Delete the local branch named 'branch3' git branch -d branch3 Confirm branch3 no longer exists in the local Git repository with the following command: # Display all local git branches git branch Notice that main is now the only branch in your local Git repository. You did it! You: Set up a new GitHub repository. Set up a local Git environment in a Docker Container. Managed local Git repository branches. Staged and committed local Git repository changes. Pushed branches and changes from your local Git environment to GitHub. Merged changes in GitHub with a pull request. Synchronized merged GitHub changes to your local Git environment. Click the link below to go to the last section and finish things up: Next Section > Clone Another Repository, Make Changes, and Create a New Pull Request","title":"Pull Changes from GitHub"},{"location":"sections/section_13/","text":"Clone Another Repository, Make Changes, and Create a New Pull Request The best way to become and stay familiar with Git is, as with so many things, to practice! Here's a challenge to help you and someone else improve your Git skills. Use what you learned to: Clone someone else's GitHub repository to your local development/Git environment. Create your own local branch in the cloned repository. Make changes to your local copy of the Git repository, within your new branch. Stage, commit, and push your local changes to the GitHub repository. Create a pull request and wait for the repository owner to merge your changes. Pull the merged changes into your local Git repository. Back to Repository Home","title":"Clone Another Repository, Make Changes, and Create a New Pull Request"},{"location":"sections/section_13/#clone-another-repository-make-changes-and-create-a-new-pull-request","text":"The best way to become and stay familiar with Git is, as with so many things, to practice! Here's a challenge to help you and someone else improve your Git skills. Use what you learned to: Clone someone else's GitHub repository to your local development/Git environment. Create your own local branch in the cloned repository. Make changes to your local copy of the Git repository, within your new branch. Stage, commit, and push your local changes to the GitHub repository. Create a pull request and wait for the repository owner to merge your changes. Pull the merged changes into your local Git repository. Back to Repository Home","title":"Clone Another Repository, Make Changes, and Create a New Pull Request"},{"location":"sections/section_2/","text":"Setup GitHub Authentication GitHub Version Control Overview Git is a distributed Version Control System (VCS) which means any copy of any Git repository can function independently of any other copies of the same Git repository. A Git repository can reside on any single computer, Container, etc. and there are also hosted or managed Git solutions which provide a central location to aggregate changes to version-controlled files. GitHub is one example of a hosted or managed Git solution. These hosted/managed solutions allow many people to run local instances of Git software on their computers and keep their version-controlled files, source code, documentation, etc. in sync with one another. This remainder of this walkthrough will show you how to: Create a centralized Git repository on GitHub. Synchronize the GitHub repository with our local Git environment (the 'git-foundations' Docker Container). Make changes to the local Git repository. Merge local Git repository changes to GitHub. GitHub Authentication Overview Before we setup a GitHub repository, it's a good idea to consider how our local Git environment (the 'git-foundations' Container) will authenticate to GitHub during repository synchronization events (clone, pull, push, etc). GitHub supports two types of secure transport, each with their own authentication mechanism(s): HTTPS with basic authentication (username and password) or API key. SSH with public/private key authentication. Either choice is just as good as the other. In this environment, we use SSH because it allows us to secure communication without having to manage credentials or API keys. We will set up SSH authentication before we create a GitHub repository. Generate an SSH Key Pair From the Docker Container prompt, generate an SSH key pair with the following command: # Generate a new public/private SSH key pair ssh-keygen After you enter this command and press your Return/Enter key, you may press your Return/Enter three more times , to accept the default storage location for the key and to accept and confirm the default, blank passphrase. Your terminal output will look something like this: Display the new SSH public key file in the terminal with this command: # Displays the contents of the new SSH public key file cat ~/.ssh/id_rsa.pub Caution Treat your SSH keys as if they were any other form of credentials and do not share them with anyone. Copy the full contents of the SSH public key output to your clipboard, including the ssh-rsa at the beginning of the file and the root@ container_id at the end of the file. We will share the text from this file with GitHub to establish mutual trust between our Container and GitHub. Setup GitHub SSH Key Authentication Navigate to https://github.com/login , log in, click the Profile icon in the upper-right corner of the window, and choose Settings . Click on the SSH and GPG keys tab on the left side of the window. Click the green, New SSH key button Provide a title for the SSH key (any title you like is just fine), paste the SSH key file text from your Container into the Key field, and click the green, Add SSH key button. Confirm that GitHub now has a copy of your container's SSH public key. SSH authentication setup is complete and we are ready to create a new GitHub repository. Click the link below to continue: Next Section > Create a GitHub Repository","title":"Set up GitHub Authentication"},{"location":"sections/section_2/#setup-github-authentication","text":"","title":"Setup GitHub Authentication"},{"location":"sections/section_2/#github-version-control-overview","text":"Git is a distributed Version Control System (VCS) which means any copy of any Git repository can function independently of any other copies of the same Git repository. A Git repository can reside on any single computer, Container, etc. and there are also hosted or managed Git solutions which provide a central location to aggregate changes to version-controlled files. GitHub is one example of a hosted or managed Git solution. These hosted/managed solutions allow many people to run local instances of Git software on their computers and keep their version-controlled files, source code, documentation, etc. in sync with one another. This remainder of this walkthrough will show you how to: Create a centralized Git repository on GitHub. Synchronize the GitHub repository with our local Git environment (the 'git-foundations' Docker Container). Make changes to the local Git repository. Merge local Git repository changes to GitHub.","title":"GitHub Version Control Overview"},{"location":"sections/section_2/#github-authentication-overview","text":"Before we setup a GitHub repository, it's a good idea to consider how our local Git environment (the 'git-foundations' Container) will authenticate to GitHub during repository synchronization events (clone, pull, push, etc). GitHub supports two types of secure transport, each with their own authentication mechanism(s): HTTPS with basic authentication (username and password) or API key. SSH with public/private key authentication. Either choice is just as good as the other. In this environment, we use SSH because it allows us to secure communication without having to manage credentials or API keys. We will set up SSH authentication before we create a GitHub repository.","title":"GitHub Authentication Overview"},{"location":"sections/section_2/#generate-an-ssh-key-pair","text":"From the Docker Container prompt, generate an SSH key pair with the following command: # Generate a new public/private SSH key pair ssh-keygen After you enter this command and press your Return/Enter key, you may press your Return/Enter three more times , to accept the default storage location for the key and to accept and confirm the default, blank passphrase. Your terminal output will look something like this: Display the new SSH public key file in the terminal with this command: # Displays the contents of the new SSH public key file cat ~/.ssh/id_rsa.pub Caution Treat your SSH keys as if they were any other form of credentials and do not share them with anyone. Copy the full contents of the SSH public key output to your clipboard, including the ssh-rsa at the beginning of the file and the root@ container_id at the end of the file. We will share the text from this file with GitHub to establish mutual trust between our Container and GitHub.","title":"Generate an SSH Key Pair"},{"location":"sections/section_2/#setup-github-ssh-key-authentication","text":"Navigate to https://github.com/login , log in, click the Profile icon in the upper-right corner of the window, and choose Settings . Click on the SSH and GPG keys tab on the left side of the window. Click the green, New SSH key button Provide a title for the SSH key (any title you like is just fine), paste the SSH key file text from your Container into the Key field, and click the green, Add SSH key button. Confirm that GitHub now has a copy of your container's SSH public key. SSH authentication setup is complete and we are ready to create a new GitHub repository. Click the link below to continue: Next Section > Create a GitHub Repository","title":"Setup GitHub SSH Key Authentication"},{"location":"sections/section_3/","text":"Create a GitHub Repository You have the option to create Git repositories either on your local machine (within a Docker Container in our case) or in a remote Git environment; it's a mater of personal preference. In either case, you can keep the Git repositories in sync with each other. In this example, we will create a Git repository on GitHub and then, later, clone the repository to our local environment. Create a new GitHub Repository Navigate to https://github.com/login and log in. The view you see may vary depending on whether or not your GitHub account is new. You should see a green button on the left side of the window which reads either Create repository , New repository , or something similar. If you don't see the button, navigate to your GitHub home page with click to the GitHub logo in the upper-left corner of any GitHub window. ![github-new-repo](../images/github-new-repo.png \"Create new repository\") !!! example You need to enter some information and choose a few options to create the repository: - **Name** \u2014 **_git-repo-1_** - **Description** \u2014 **_Git Repository \\#1_** - Set your repository to **Public** - Tick the box to **Initialize this repository with a README** - :warning: The **Name** and **Description** values provide the initial title and contents for the repository README file. - Expand the **Add .gitignore** dropdown and type or choose **Python** - Click the **Create repository** button ![github-new-repo-details](../images/github-new-repo-details.png \"Add new repository details\") --- Take a look at your new repository! You have two files, .gitignore and README.md . Your new repository is ready to use. Next, we will briefly look at GitHub branches. Click the link below to continue: Next Section > Create a New Branch in a GitHub Repository","title":"Set up a GitHub Repository"},{"location":"sections/section_3/#create-a-github-repository","text":"You have the option to create Git repositories either on your local machine (within a Docker Container in our case) or in a remote Git environment; it's a mater of personal preference. In either case, you can keep the Git repositories in sync with each other. In this example, we will create a Git repository on GitHub and then, later, clone the repository to our local environment.","title":"Create a GitHub Repository"},{"location":"sections/section_3/#create-a-new-github-repository","text":"Navigate to https://github.com/login and log in. The view you see may vary depending on whether or not your GitHub account is new. You should see a green button on the left side of the window which reads either Create repository , New repository , or something similar. If you don't see the button, navigate to your GitHub home page with click to the GitHub logo in the upper-left corner of any GitHub window. ![github-new-repo](../images/github-new-repo.png \"Create new repository\") !!! example You need to enter some information and choose a few options to create the repository: - **Name** \u2014 **_git-repo-1_** - **Description** \u2014 **_Git Repository \\#1_** - Set your repository to **Public** - Tick the box to **Initialize this repository with a README** - :warning: The **Name** and **Description** values provide the initial title and contents for the repository README file. - Expand the **Add .gitignore** dropdown and type or choose **Python** - Click the **Create repository** button ![github-new-repo-details](../images/github-new-repo-details.png \"Add new repository details\") --- Take a look at your new repository! You have two files, .gitignore and README.md . Your new repository is ready to use. Next, we will briefly look at GitHub branches. Click the link below to continue: Next Section > Create a New Branch in a GitHub Repository","title":"Create a new GitHub Repository"},{"location":"sections/section_4/","text":"Create a New Branch in a GitHub Repository It is common for several people to work on the code or contents within a GitHub repository at the same time. Each person can work within their own branch, an isolated copy of the repository code, so their changes don't accidentally conflict with each other. Before we clone our new repository to our Docker Container, let's create a new branch from the default, main branch. This will simulate the scenario that someone else already started working on changes to the repository within their own branch. Info It is more common and generally a best practice to create new branches within local development environments and then to push those branches to GitHub. This step illustrates a point which we will review in a subsequent section. Click the Branch: main button to expand the Branch drop-down menu. Type the name branch1 for the new branch and then click the text Create branch: branch1 from 'main' . Click the Branch: branch1 button to expand the Branch drop-down menu. Notice that there are now two branches, main and branch1 . It's time to get a copy of our GitHub repository into our Docker environment. Click the link below to continue: Next Section > Clone a GitHub Repository to Your Computer","title":"Create a New Branch in a GitHub Repository"},{"location":"sections/section_4/#create-a-new-branch-in-a-github-repository","text":"It is common for several people to work on the code or contents within a GitHub repository at the same time. Each person can work within their own branch, an isolated copy of the repository code, so their changes don't accidentally conflict with each other. Before we clone our new repository to our Docker Container, let's create a new branch from the default, main branch. This will simulate the scenario that someone else already started working on changes to the repository within their own branch. Info It is more common and generally a best practice to create new branches within local development environments and then to push those branches to GitHub. This step illustrates a point which we will review in a subsequent section. Click the Branch: main button to expand the Branch drop-down menu. Type the name branch1 for the new branch and then click the text Create branch: branch1 from 'main' . Click the Branch: branch1 button to expand the Branch drop-down menu. Notice that there are now two branches, main and branch1 . It's time to get a copy of our GitHub repository into our Docker environment. Click the link below to continue: Next Section > Clone a GitHub Repository to Your Computer","title":"Create a New Branch in a GitHub Repository"},{"location":"sections/section_5/","text":"Clone a GitHub Repository to Your Computer Now it's time for us to work with the files in our GitHub repository, and we start by copying or cloning the repository to our local Docker Container environment. Copy The Repository SSH URL We mentioned GitHub supports two transports, HTTPS and SSH. GitHub defaults to HTTPS transport, which adds an extra step (entering your username and password) to the cloning process. The SSH keys we setup in Section 2 allow our Docker Container and GitHub to communicate with each other without repeatedly prompting for credentials. Click the green Clone button and notice that GitHub displays an HTTPS URL. Click the SSH link to change the display to an SSH URL. Click the Copy icon, just to the right of the SSH URL, to store the URL on your clipboard. Clone & Review The Repository Return to your Docker Container prompt, type the command git clone , paste your repository URL , as shown in the example below (your repository URL will be different than the example in the in the following code block), and press your Return/Enter key: # Download a new copy of a GitHub repository to a local system (our Container, in this case) git clone git@github.com:your-repository-url/git-repo-1.git Attention You will likely see a prompt which asks you to confirm the authenticity of GitHub's SSH RSA fingerprint. You may safely type yes and press Return/Enter to continue. The result of the git clone command should look something like this: List your directory contents to view your repository folder, git-repo-1 , with the following command: # List the contents of the current directory in long format ls -l Change to your repository directory and display your current working directory with the following commands: # Change the current working directory from development to /development/git-repo-1 cd git-repo-1 # Display the current working directory pwd Let's take a quick look at the contents of your repository directory, including the hidden files, with the following command. # List the contents of the current directory, including hidden files, in long format ls -la Notice that both of the files in your GitHub repository ( .gitignore and README.md ) are now in our Docker Container. View the contents of the README.md file with the following command: # Display the contents of the file 'README.md' cat README.md There is one item in our repository directory which isn't in our GitHub repository, the .git directory. This directory contains all of the details about your local repository and you should rarely, if ever, have to interact with these files. Just to see what the contents of this folder look like, use the following command: # List the contents of the .git directory in long format ls -l .git We now have a copy of our GitHub repository in our Docker environment. Before we make changes to our local copy of the Git repository, we need to configure a few local Git settings. Click the link below to continue: Next Section > View & Configure Local Git Settings on Your Computer","title":"Clone a GitHub Repository to Your Computer"},{"location":"sections/section_5/#clone-a-github-repository-to-your-computer","text":"Now it's time for us to work with the files in our GitHub repository, and we start by copying or cloning the repository to our local Docker Container environment.","title":"Clone a GitHub Repository to Your Computer"},{"location":"sections/section_5/#copy-the-repository-ssh-url","text":"We mentioned GitHub supports two transports, HTTPS and SSH. GitHub defaults to HTTPS transport, which adds an extra step (entering your username and password) to the cloning process. The SSH keys we setup in Section 2 allow our Docker Container and GitHub to communicate with each other without repeatedly prompting for credentials. Click the green Clone button and notice that GitHub displays an HTTPS URL. Click the SSH link to change the display to an SSH URL. Click the Copy icon, just to the right of the SSH URL, to store the URL on your clipboard.","title":"Copy The Repository SSH URL"},{"location":"sections/section_5/#clone-review-the-repository","text":"Return to your Docker Container prompt, type the command git clone , paste your repository URL , as shown in the example below (your repository URL will be different than the example in the in the following code block), and press your Return/Enter key: # Download a new copy of a GitHub repository to a local system (our Container, in this case) git clone git@github.com:your-repository-url/git-repo-1.git Attention You will likely see a prompt which asks you to confirm the authenticity of GitHub's SSH RSA fingerprint. You may safely type yes and press Return/Enter to continue. The result of the git clone command should look something like this: List your directory contents to view your repository folder, git-repo-1 , with the following command: # List the contents of the current directory in long format ls -l Change to your repository directory and display your current working directory with the following commands: # Change the current working directory from development to /development/git-repo-1 cd git-repo-1 # Display the current working directory pwd Let's take a quick look at the contents of your repository directory, including the hidden files, with the following command. # List the contents of the current directory, including hidden files, in long format ls -la Notice that both of the files in your GitHub repository ( .gitignore and README.md ) are now in our Docker Container. View the contents of the README.md file with the following command: # Display the contents of the file 'README.md' cat README.md There is one item in our repository directory which isn't in our GitHub repository, the .git directory. This directory contains all of the details about your local repository and you should rarely, if ever, have to interact with these files. Just to see what the contents of this folder look like, use the following command: # List the contents of the .git directory in long format ls -l .git We now have a copy of our GitHub repository in our Docker environment. Before we make changes to our local copy of the Git repository, we need to configure a few local Git settings. Click the link below to continue: Next Section > View & Configure Local Git Settings on Your Computer","title":"Clone &amp; Review The Repository"},{"location":"sections/section_6/","text":"View & Configure the Local Git Settings in your Docker Container Git requires very little information before we can start to make local repository changes and then push those changes to GitHub. We just need to tell Git the name and email address of the person contributing changes, as a way to help all repository viewers and contributors understand who contributes what. We provide Git with our name and email address using one or more configuration files. Git has several tiers of configuration files, and we will explore the three most common: System-wide \u2014 /etc/gitconfig Applies to all repositories for all users on a system. Global \u2014 ~/.gitconfig Applies to all repositories for a single user on a system. Supersedes any overlapping system-wide settings. Local repository \u2014 repository_folder/.git/config Applies to a single repository. Supersedes any overlapping global and system-wide settings. Git Name & Email Address Configuration It is most typical for people to add their name and email address to their global configuration settings, thereby making it possible to perform Git operations on any repository within their user profile. If a few Git repositories within a user profile require a different name or email address combination, it is typical to set those at the local repository level, on a case-by-case basis. For the purpose of familiarization with the process to configure different Git configuration files, we will configure our Docker environment in a somewhat non-typical, although functional way. Edit Git Configuration Files From your Docker container prompt, configure a system-wide Git username and email address with the following commands: git config --system user.name \"Your Name - System\" # Replace 'Your Name' with your first/last name git config --system user.email \"git_docker_container@wwt.com\" # For demonstration purposes, do not replace this email address Review the system-wide Git configuration file with the following command: # Display the contents of the file /etc/gitconfig cat /etc/gitconfig Notice the name and email values which are part of the Git system configuration file. Right now, these settings apply to all Git repositories for all users in our environment. Note Typically, you would simply enter your name without the - System suffix. This suffix will allow us to distinguish which configuration settings take precedence when configuration file overlap occurs. Configure a Global Git username and email address with the following commands: git config --global user.name \"Your Name - Global\" # Replace 'Your Name' with your first/last name git config --global user.email \"your.email@your_domain.com\" # Replace 'your.email@your_domain.com' with your email address Review the Git global configuration file with the following command: # Display the contents of the file /root/.gitconfig # ~/ is shorthand for the home directory for the current user cat ~/.gitconfig Notice the name and email which values are part of the Git global configuration file. Right now, these settings apply to all Git repositories for our current user profile. Effectively, this is all of the repositories in our Docker environment, which means the Git system configuration settings no longer apply. Again, you would normally enter your name without the - Global suffix. To configure a Git name or email for a local repository , make sure your working directory is that of the repository you want to configure (you may display your current working directory with the pwd command). Configure the local repository Git username with the following command: git config user.name \"Your Name - Repo\" # Replace 'Your Name' with your first/last name Review the local Git configuration file for the git-repo-1 repository with the following command: # Display the contents of the file .git/config cat .git/config Notice there is a name value but no email value in the local repository configuration file. Review Effective Git Configuration Settings Since we just set Git configuration values in three separate places, we need to determine which values Git will use when we commit changes to our repository. To do that enter the following commands: # Display the current working directory pwd # Display the user name that Git will use for commits within the current directory git config user.name # Display the email address that Git will use for commits to the current repository git config user.email We set a user.name value within the local repository and Git returns that value (notice the repo name suffix). Since we didn't set a local repository email, Git looks to the next higher level configuration file, the global Git configuration file, for an email address and displays that address. If we change our working directory such that we are no longer within this repository, we can see the difference in the effective Git configuration for repositories without specific configurations. Use the following commands to navigate to a different directory and check Git configuration settings: # Change the current working directory from /development/git-repo-1 to /development cd .. # Display the current working directory pwd # Display the user name that Git will use for commits within the current directory git config user.name # Display the email address that Git will use for commits within the current directory git config user.email Outside our repository directory we see the both the user.name and user.email values come from the global configuration file (notice the Global suffix after the username ). Change the working directory back to the local GIt repository directory before we continue with the following command: # Change the current working directory from development to /development/git-repo-1 cd git-repo-1 # Display the current working directory pwd We have all of the Git configuration settings in place to start working with our Git repository. Click the link below to continue: Next Section > Manage Local Git Branches","title":"View & Configure Local Git Settings"},{"location":"sections/section_6/#view-configure-the-local-git-settings-in-your-docker-container","text":"Git requires very little information before we can start to make local repository changes and then push those changes to GitHub. We just need to tell Git the name and email address of the person contributing changes, as a way to help all repository viewers and contributors understand who contributes what. We provide Git with our name and email address using one or more configuration files. Git has several tiers of configuration files, and we will explore the three most common: System-wide \u2014 /etc/gitconfig Applies to all repositories for all users on a system. Global \u2014 ~/.gitconfig Applies to all repositories for a single user on a system. Supersedes any overlapping system-wide settings. Local repository \u2014 repository_folder/.git/config Applies to a single repository. Supersedes any overlapping global and system-wide settings.","title":"View &amp; Configure the Local Git Settings in your Docker Container"},{"location":"sections/section_6/#git-name-email-address-configuration","text":"It is most typical for people to add their name and email address to their global configuration settings, thereby making it possible to perform Git operations on any repository within their user profile. If a few Git repositories within a user profile require a different name or email address combination, it is typical to set those at the local repository level, on a case-by-case basis. For the purpose of familiarization with the process to configure different Git configuration files, we will configure our Docker environment in a somewhat non-typical, although functional way.","title":"Git Name &amp; Email Address Configuration"},{"location":"sections/section_6/#edit-git-configuration-files","text":"From your Docker container prompt, configure a system-wide Git username and email address with the following commands: git config --system user.name \"Your Name - System\" # Replace 'Your Name' with your first/last name git config --system user.email \"git_docker_container@wwt.com\" # For demonstration purposes, do not replace this email address Review the system-wide Git configuration file with the following command: # Display the contents of the file /etc/gitconfig cat /etc/gitconfig Notice the name and email values which are part of the Git system configuration file. Right now, these settings apply to all Git repositories for all users in our environment. Note Typically, you would simply enter your name without the - System suffix. This suffix will allow us to distinguish which configuration settings take precedence when configuration file overlap occurs. Configure a Global Git username and email address with the following commands: git config --global user.name \"Your Name - Global\" # Replace 'Your Name' with your first/last name git config --global user.email \"your.email@your_domain.com\" # Replace 'your.email@your_domain.com' with your email address Review the Git global configuration file with the following command: # Display the contents of the file /root/.gitconfig # ~/ is shorthand for the home directory for the current user cat ~/.gitconfig Notice the name and email which values are part of the Git global configuration file. Right now, these settings apply to all Git repositories for our current user profile. Effectively, this is all of the repositories in our Docker environment, which means the Git system configuration settings no longer apply. Again, you would normally enter your name without the - Global suffix. To configure a Git name or email for a local repository , make sure your working directory is that of the repository you want to configure (you may display your current working directory with the pwd command). Configure the local repository Git username with the following command: git config user.name \"Your Name - Repo\" # Replace 'Your Name' with your first/last name Review the local Git configuration file for the git-repo-1 repository with the following command: # Display the contents of the file .git/config cat .git/config Notice there is a name value but no email value in the local repository configuration file.","title":"Edit Git Configuration Files"},{"location":"sections/section_6/#review-effective-git-configuration-settings","text":"Since we just set Git configuration values in three separate places, we need to determine which values Git will use when we commit changes to our repository. To do that enter the following commands: # Display the current working directory pwd # Display the user name that Git will use for commits within the current directory git config user.name # Display the email address that Git will use for commits to the current repository git config user.email We set a user.name value within the local repository and Git returns that value (notice the repo name suffix). Since we didn't set a local repository email, Git looks to the next higher level configuration file, the global Git configuration file, for an email address and displays that address. If we change our working directory such that we are no longer within this repository, we can see the difference in the effective Git configuration for repositories without specific configurations. Use the following commands to navigate to a different directory and check Git configuration settings: # Change the current working directory from /development/git-repo-1 to /development cd .. # Display the current working directory pwd # Display the user name that Git will use for commits within the current directory git config user.name # Display the email address that Git will use for commits within the current directory git config user.email Outside our repository directory we see the both the user.name and user.email values come from the global configuration file (notice the Global suffix after the username ). Change the working directory back to the local GIt repository directory before we continue with the following command: # Change the current working directory from development to /development/git-repo-1 cd git-repo-1 # Display the current working directory pwd We have all of the Git configuration settings in place to start working with our Git repository. Click the link below to continue: Next Section > Manage Local Git Branches","title":"Review Effective Git Configuration Settings"},{"location":"sections/section_7/","text":"Manage Local Git Branches Our Git environment is ready for us to start work on our repository. Typically, especially on a project with many contributors, Git branches allow each contributor to have as many non-overlapping copies of the repository as they need, to make and manage their changes. We will do some basic work with branches, so we can, later, contribute our changes to the main branch of the GitHub repository. View, Create, Switch To, & Remove Branches From the Docker Container prompt, list your local Git branches with the following command: # Display all local git branches git branch Notice that only the main branch cloned to your local Git repository from GitHub. This is normal/expected behavior; only the main branch clones from GitHub because other branches (like the branch1 branch we created in GitHub) are likely other peoples' work in-progress and any work we do should originate from the main branch of the GitHub repository. The asterisk to the left of \"main\" indicates that main is our current, working branch. List all Git repository branches, local and remote, with the following command: # Display all local and remote repository git branches git branch -a Notice how we see: A main branch. This is our local copy of the main branch. An origin/main branch alias (for remotes/origin/HEAD ). This is the copy of the main branch in Github. And an origin/remotes/branch1 branch. This is the copy of the branch1 branch in Github. Info Origin is how our local repository refers to GitHub so origin/main represents the main branch on GitHub. Create a new, local branch named branch2 , with the following command: # Create a new local git branch named 'branch2' git branch branch2 List your local branches again with the following command: # Display all local git branches git branch Notice your new branch, branch2 and also that the asterisk next to main tells us that, even though we just created branch2 , our working branch is still main . Again, list all branches, local and remote, with the following command: # Display all local and remote repository git branches git branch -a Notice that branch2 does not exist as a remote branch in GitHub. This is normal behavior and something we will work with later on. Switch your working branch to branch2 with the following command: # Switch the working branch from 'main' to 'branch2' git checkout branch2 Verify your current, working branch with the following command: # Display all local git branches git branch Notice the asterisk next to branch2 which indicates that branch2 is our current, working branch. Create and simultaneously switch to a new branch with the following command: # Create and switch the working branch to a new local git branch named 'branch3' git checkout -b branch3 The git checkout command allows you to switch between branches. The git checkout command with the -b flag creates a new branch and switches to the new branch. Tip The git checkout -b branch_name command is just a shortcut for the git branch branch_name command followed by git checkout branch_name command. List your local branches again with the following command: # Display all local git branches git branch Notice the asterisk next to branch3 which indicates that branch3 is our current, working branch. For our purpose, we only need one branch, in addition to the main branch, so we can remove one of our new branches with the following command: # Delete the local branch named 'branch2' git branch -d branch2 Tip Git will not allow you to delete your current, working branch. Review your local branches with the following command: # Display all local git branches git branch Notice that branch2 is no longer available. We can make some changes to our repository within branch3 without impacting the main branch. Click the link below to continue: Next Section > Make Local Git Repository Changes","title":"Manage Local Git Branches"},{"location":"sections/section_7/#manage-local-git-branches","text":"Our Git environment is ready for us to start work on our repository. Typically, especially on a project with many contributors, Git branches allow each contributor to have as many non-overlapping copies of the repository as they need, to make and manage their changes. We will do some basic work with branches, so we can, later, contribute our changes to the main branch of the GitHub repository.","title":"Manage Local Git Branches"},{"location":"sections/section_7/#view-create-switch-to-remove-branches","text":"From the Docker Container prompt, list your local Git branches with the following command: # Display all local git branches git branch Notice that only the main branch cloned to your local Git repository from GitHub. This is normal/expected behavior; only the main branch clones from GitHub because other branches (like the branch1 branch we created in GitHub) are likely other peoples' work in-progress and any work we do should originate from the main branch of the GitHub repository. The asterisk to the left of \"main\" indicates that main is our current, working branch. List all Git repository branches, local and remote, with the following command: # Display all local and remote repository git branches git branch -a Notice how we see: A main branch. This is our local copy of the main branch. An origin/main branch alias (for remotes/origin/HEAD ). This is the copy of the main branch in Github. And an origin/remotes/branch1 branch. This is the copy of the branch1 branch in Github. Info Origin is how our local repository refers to GitHub so origin/main represents the main branch on GitHub. Create a new, local branch named branch2 , with the following command: # Create a new local git branch named 'branch2' git branch branch2 List your local branches again with the following command: # Display all local git branches git branch Notice your new branch, branch2 and also that the asterisk next to main tells us that, even though we just created branch2 , our working branch is still main . Again, list all branches, local and remote, with the following command: # Display all local and remote repository git branches git branch -a Notice that branch2 does not exist as a remote branch in GitHub. This is normal behavior and something we will work with later on. Switch your working branch to branch2 with the following command: # Switch the working branch from 'main' to 'branch2' git checkout branch2 Verify your current, working branch with the following command: # Display all local git branches git branch Notice the asterisk next to branch2 which indicates that branch2 is our current, working branch. Create and simultaneously switch to a new branch with the following command: # Create and switch the working branch to a new local git branch named 'branch3' git checkout -b branch3 The git checkout command allows you to switch between branches. The git checkout command with the -b flag creates a new branch and switches to the new branch. Tip The git checkout -b branch_name command is just a shortcut for the git branch branch_name command followed by git checkout branch_name command. List your local branches again with the following command: # Display all local git branches git branch Notice the asterisk next to branch3 which indicates that branch3 is our current, working branch. For our purpose, we only need one branch, in addition to the main branch, so we can remove one of our new branches with the following command: # Delete the local branch named 'branch2' git branch -d branch2 Tip Git will not allow you to delete your current, working branch. Review your local branches with the following command: # Display all local git branches git branch Notice that branch2 is no longer available. We can make some changes to our repository within branch3 without impacting the main branch. Click the link below to continue: Next Section > Make Local Git Repository Changes","title":"View, Create, Switch To, &amp; Remove Branches"},{"location":"sections/section_8/","text":"Make Local Git Repository Changes Let's make a change to one of the files in our local Git repository and see how Git reacts to that change. Append the README.md File From the Docker Container prompt, view the status of your local Git repository with the following command: # Display status information for the current git repository git status Notice your working branch is branch3 and that you have no changes to commit (indicated by the nothing to commit output. Write a new line to the README.md file with the following command: # Append a new line of text ('This is a new line...'') to the file 'README.md' echo 'This is a new line in the README.md file' >> README.md View the changes between the copy of README.md in the working directory and the local Git repository with the following command: # Display changes between the working and committed files within the git repository git diff Notice the + character next to the last line in the git diff output. This indicates the a change between the README.md file in the working directory and the copy of README.md which is already in (committed to) the local Git repository. View the of your local Git repository with the following command: # Display status information for the current git repository git status Notice the README.md file in the section, Changes not staged for commit . We made a change to one of the files in our working directory and next up is the process to move files from the working directory, to the staging area, and to the local repository (HEAD). Click the link below to continue: Next Section > Make Local Git Repository Changes With Atomic Commits","title":"Make Local Git Repository Changes"},{"location":"sections/section_8/#make-local-git-repository-changes","text":"Let's make a change to one of the files in our local Git repository and see how Git reacts to that change.","title":"Make Local Git Repository Changes"},{"location":"sections/section_8/#append-the-readmemd-file","text":"From the Docker Container prompt, view the status of your local Git repository with the following command: # Display status information for the current git repository git status Notice your working branch is branch3 and that you have no changes to commit (indicated by the nothing to commit output. Write a new line to the README.md file with the following command: # Append a new line of text ('This is a new line...'') to the file 'README.md' echo 'This is a new line in the README.md file' >> README.md View the changes between the copy of README.md in the working directory and the local Git repository with the following command: # Display changes between the working and committed files within the git repository git diff Notice the + character next to the last line in the git diff output. This indicates the a change between the README.md file in the working directory and the copy of README.md which is already in (committed to) the local Git repository. View the of your local Git repository with the following command: # Display status information for the current git repository git status Notice the README.md file in the section, Changes not staged for commit . We made a change to one of the files in our working directory and next up is the process to move files from the working directory, to the staging area, and to the local repository (HEAD). Click the link below to continue: Next Section > Make Local Git Repository Changes With Atomic Commits","title":"Append the README.md File"},{"location":"sections/section_9/","text":"Make Local Git Repository Changes With Atomic Commits It is possible to commit many changes to a single file at once although doing so can make it difficult to find and roll-back individual changes within a commit. Alternatively, atomic commits are those which involve a separate commit for each change to a file. While atomic commits can be more tedious, they provide the benefit of isolating individual changes to individual commits. Create and Commit a New Python Script to the Repository Let's create a new file, a simple Python script, in our repository. The file will be blank to start, but we will add some code to the file shortly. In the next series of commands we will: Create a Python script. List the contents of the repository directory. Review the Git repository status. # Create a new, blank file named 'my_script.py' touch my_script.py # List the contents of the current directory in long format ls -l # Display status information for the current git repository git status Notice the following: The my_script.py file exists and is empty (0 bytes). The my_script.py file is in the Untracked files section of the git status output. Tip An untracked file is a file which the local Git repository has not seen before. Issue commands to: Add the my_script.py file to the Git staging area. Review the status of the Git repository. # Move the 'my_script.py' file from the working directory to the staging area git add my_script.py # Display status information for the current git repository git status Notice that the my_script.py file is now in the Changes to be committed section. This indicates my_script.py is in the Git staging area . Issue commands to: Commit the my_script.py file to the local Git repository with the git commit command, followed by the -m option and a message about the commit details. The -m command option prefixes the required message that accompanies a commit to a Git repository. There are other ways to add a message to a commit, although the -m option is, generally, the simplest. Review the status of the local Git repository. Caution Commits to a Git repository require a commit message which should describe changes adequately enough that someone else can understand the overall theme or intent of the changes. Danger The -m option after the git commit command allows you to enter a commit message inline. If you omit the -m option, Git will open the default text editor for the OS (VIM is the default editor for most Linux distributions) and prompt for a commit message. Tip If you happen to end up in the Docker Container VIM editor, press the esc key, type :q! , and press Return or Enter . # Move the file 'my_script.py' from the staging area to the repository git commit -m \"Initial commit of 'my_script.py'\" # Display status information for the current git repository git status Notice there are no changes to commit. The README.md file does have changes although isn't yet staged for commit, we will work on that shortly. Add Python Code to the my_script.py File To make changes to the my_script.py file, we will add some executable Python code. Use the following commands to add some executable Python code to my_script.py : # Python code which collects a name and displays a greeting echo '#!/usr/bin/env python' >> my_script.py echo '# This script displays a greeting' >> my_script.py echo 'name = input(\"What is your name? \")' >> my_script.py echo 'print(f\"It is nice to meet you, {name})' >> my_script.py View the changes between the copy of my_script.py file in the working directory and the copy in the local Git repository with the following command: # Display changes between the working and committed files within the git repository git diff Notice the + characters next to the last four lines in the git diff output. This indicates four lines of changes between the my_script.py file in the working directory and the copy of my_script.py which is already in (committed to) the local Git repository. View the status of your local Git repository with the following command: # Display status information for the current git repository git status We now have two changed files to stage and then commit to the local repository. Issue commands to: Move all changed files in the working directory to the staging area. Review the repository status. Commit the staged changes to the repository. # Move all changed files from the working directory to the staging area git add . Tip You may also commit individual files to the staging area. For example, to stage only the README.md file, use the command git add README.md . # Display status information for the current git repository git status # Commit all staged files to the repository with a descriptive comment git commit -m \"Appended line to README.md and added commands to my_script.py\" Notice the output from the git status command shows two files in the staging area, in the Changes to be committed section of the output. Also notice the output from the git commit command shows two files changed and a combined 5 insertions (new lines of text). View the status of your local Git repository with the following command: # Display status information for the current git repository git status Notice the working branch, branch3 shows no changes to commit. Sometimes it is necessary to roll-back to a previous repository commit or to understand the history of changes to a repository (who did what to which files). You can review the complete commit history for a repository with the git log command. # Display the logged git history for the repository git log Notice how information about the most recent commit is at the top of the git log output, and how the commit messages for each commit in the log provide important information about the changes a particular commit includes. This is one reason descriptive commit messages are important. Push Committed Changes to GitHub We now have several atomic commits in our local repository which we can now push to our GitHub repository. The git push command will synchronize the local Git repository changes with the GitHub repository. Tip To determine which remote repository a git push will send changes to, use either of the commands git remote --verbose , git remote -v , or cat .git/config . # Determine the remote repository URL git remote --verbose Attempt to push local Git repository changes to GitHub with the following command: # Push local repository changes to a remote repository git push Notice that we receive a fatal error message when we attempt to use the git push command. GitHub does not have a branch which matches the working branch in our local repository ( branch3 ) and, therefore, returns an error. Before we can push changes with a simple git push command, we need to create branch3 in GitHub. Notice in the output, after the fatal error, Git is friendly enough to display the exact command to both create branch3 in GitHub and then push our commits to GitHub. Initiate the git push again with the following command: # Push local repository changes, including the local branch, to a remote repository git push --set-upstream origin branch3 Notice that Git creates a new branch, branch3 , in GitHub, and pushes the local Git repository branch3 commits to the new GitHub branch3 . Next we will take a look at our GitHub repository to review the changes we pushed from our local Git repository. Click the link below to continue: Next Section > Review Changes in the GitHub Repository","title":"Make Local Git Repository Changes With Atomic Commits"},{"location":"sections/section_9/#make-local-git-repository-changes-with-atomic-commits","text":"It is possible to commit many changes to a single file at once although doing so can make it difficult to find and roll-back individual changes within a commit. Alternatively, atomic commits are those which involve a separate commit for each change to a file. While atomic commits can be more tedious, they provide the benefit of isolating individual changes to individual commits.","title":"Make Local Git Repository Changes With Atomic Commits"},{"location":"sections/section_9/#create-and-commit-a-new-python-script-to-the-repository","text":"Let's create a new file, a simple Python script, in our repository. The file will be blank to start, but we will add some code to the file shortly. In the next series of commands we will: Create a Python script. List the contents of the repository directory. Review the Git repository status. # Create a new, blank file named 'my_script.py' touch my_script.py # List the contents of the current directory in long format ls -l # Display status information for the current git repository git status Notice the following: The my_script.py file exists and is empty (0 bytes). The my_script.py file is in the Untracked files section of the git status output. Tip An untracked file is a file which the local Git repository has not seen before. Issue commands to: Add the my_script.py file to the Git staging area. Review the status of the Git repository. # Move the 'my_script.py' file from the working directory to the staging area git add my_script.py # Display status information for the current git repository git status Notice that the my_script.py file is now in the Changes to be committed section. This indicates my_script.py is in the Git staging area . Issue commands to: Commit the my_script.py file to the local Git repository with the git commit command, followed by the -m option and a message about the commit details. The -m command option prefixes the required message that accompanies a commit to a Git repository. There are other ways to add a message to a commit, although the -m option is, generally, the simplest. Review the status of the local Git repository. Caution Commits to a Git repository require a commit message which should describe changes adequately enough that someone else can understand the overall theme or intent of the changes. Danger The -m option after the git commit command allows you to enter a commit message inline. If you omit the -m option, Git will open the default text editor for the OS (VIM is the default editor for most Linux distributions) and prompt for a commit message. Tip If you happen to end up in the Docker Container VIM editor, press the esc key, type :q! , and press Return or Enter . # Move the file 'my_script.py' from the staging area to the repository git commit -m \"Initial commit of 'my_script.py'\" # Display status information for the current git repository git status Notice there are no changes to commit. The README.md file does have changes although isn't yet staged for commit, we will work on that shortly.","title":"Create and Commit a New Python Script to the Repository"},{"location":"sections/section_9/#add-python-code-to-the-my_scriptpy-file","text":"To make changes to the my_script.py file, we will add some executable Python code. Use the following commands to add some executable Python code to my_script.py : # Python code which collects a name and displays a greeting echo '#!/usr/bin/env python' >> my_script.py echo '# This script displays a greeting' >> my_script.py echo 'name = input(\"What is your name? \")' >> my_script.py echo 'print(f\"It is nice to meet you, {name})' >> my_script.py View the changes between the copy of my_script.py file in the working directory and the copy in the local Git repository with the following command: # Display changes between the working and committed files within the git repository git diff Notice the + characters next to the last four lines in the git diff output. This indicates four lines of changes between the my_script.py file in the working directory and the copy of my_script.py which is already in (committed to) the local Git repository. View the status of your local Git repository with the following command: # Display status information for the current git repository git status We now have two changed files to stage and then commit to the local repository. Issue commands to: Move all changed files in the working directory to the staging area. Review the repository status. Commit the staged changes to the repository. # Move all changed files from the working directory to the staging area git add . Tip You may also commit individual files to the staging area. For example, to stage only the README.md file, use the command git add README.md . # Display status information for the current git repository git status # Commit all staged files to the repository with a descriptive comment git commit -m \"Appended line to README.md and added commands to my_script.py\" Notice the output from the git status command shows two files in the staging area, in the Changes to be committed section of the output. Also notice the output from the git commit command shows two files changed and a combined 5 insertions (new lines of text). View the status of your local Git repository with the following command: # Display status information for the current git repository git status Notice the working branch, branch3 shows no changes to commit. Sometimes it is necessary to roll-back to a previous repository commit or to understand the history of changes to a repository (who did what to which files). You can review the complete commit history for a repository with the git log command. # Display the logged git history for the repository git log Notice how information about the most recent commit is at the top of the git log output, and how the commit messages for each commit in the log provide important information about the changes a particular commit includes. This is one reason descriptive commit messages are important.","title":"Add Python Code to the my_script.py File"},{"location":"sections/section_9/#push-committed-changes-to-github","text":"We now have several atomic commits in our local repository which we can now push to our GitHub repository. The git push command will synchronize the local Git repository changes with the GitHub repository. Tip To determine which remote repository a git push will send changes to, use either of the commands git remote --verbose , git remote -v , or cat .git/config . # Determine the remote repository URL git remote --verbose Attempt to push local Git repository changes to GitHub with the following command: # Push local repository changes to a remote repository git push Notice that we receive a fatal error message when we attempt to use the git push command. GitHub does not have a branch which matches the working branch in our local repository ( branch3 ) and, therefore, returns an error. Before we can push changes with a simple git push command, we need to create branch3 in GitHub. Notice in the output, after the fatal error, Git is friendly enough to display the exact command to both create branch3 in GitHub and then push our commits to GitHub. Initiate the git push again with the following command: # Push local repository changes, including the local branch, to a remote repository git push --set-upstream origin branch3 Notice that Git creates a new branch, branch3 , in GitHub, and pushes the local Git repository branch3 commits to the new GitHub branch3 . Next we will take a look at our GitHub repository to review the changes we pushed from our local Git repository. Click the link below to continue: Next Section > Review Changes in the GitHub Repository","title":"Push Committed Changes to GitHub"}]}